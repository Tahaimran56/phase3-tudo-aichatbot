<!--
================================================================================
SYNC IMPACT REPORT
================================================================================
Version change: 2.0.0 → 3.0.0 (MAJOR - Phase 3 AI/RAG/Localization expansion)

Modified principles:
- VII. Multi-User Isolation → Enhanced with RAG-specific isolation requirements
- II. SDD Strictness → Enhanced with explicit AI component generation mandate

Added sections:
- X. AI & RAG Governance (3 principles: Contextual Integrity, Multi-User Isolation, Privacy First)
- XI. Localization & Personalization Standards (2 principles: Technical Translation, Dynamic Personalization)
- XII. Traceability → Enhanced PHR requirements for AI reasoning capture

Removed sections:
- None (Phase 1 and Phase 2 principles retained for backwards compatibility)

Templates requiring updates:
- ✅ plan-template.md - Constitution Check already supports extensibility
- ✅ spec-template.md - User Scenarios support personalization requirements
- ✅ tasks-template.md - Task organization supports AI/RAG feature tasks
- ✅ phr-template.prompt.md - Already captures AI reasoning

Follow-up TODOs:
- None - all principles fully specified
================================================================================
-->

# The Evolution of Todo Constitution

## Core Principles

### I. Architectural Integrity

Every feature MUST begin with a Specification and a Technical Plan before any implementation work begins.

**Non-Negotiable Rules**:
- No code changes without an approved specification (`spec.md`)
- No implementation without a technical plan (`plan.md`)
- Design artifacts MUST be reviewed and approved before task generation

**Rationale**: Ensures deliberate design decisions and prevents ad-hoc development that leads to technical debt.

### II. SDD Strictness

All implementation MUST be generated by the AI agent based on approved tasks. Zero manual coding outside of the SDD workflow.

**Non-Negotiable Rules**:
- Tasks MUST be defined in `tasks.md` before implementation
- Implementation follows Red-Green-Refactor cycle when tests are specified
- Code changes MUST trace back to approved tasks
- All web components, API routes, AI components, vector sync logic, and chat interfaces MUST be generated by the AI agent based on specifications
- Atomic Commits: Commit code only after a single task from `tasks.md` is completed and verified

**Rationale**: Maintains traceability between requirements and implementation; ensures consistency and repeatability; prevents manual coding drift.

### III. Language Standard

Code MUST follow established language standards for each technology layer.

**Non-Negotiable Rules**:
- Python 3.12+ with PEP 8 compliance for backend
- Modern Python features (type hints, dataclasses, pattern matching) SHOULD be used
- TypeScript/JavaScript follows ESLint standards for frontend (when applicable)

**Rationale**: Ensures code consistency, readability, and access to modern language features.

### IV. Modularity

Code MUST be organized into clear, testable functions or classes.

**Non-Negotiable Rules**:
- Single Responsibility Principle: each function/class has one clear purpose
- Functions MUST be independently testable
- Avoid deep nesting; prefer composition over inheritance

**Rationale**: Enables unit testing, code reuse, and maintainability.

### V. Type Safety

All functions MUST include type hints or type annotations.

**Non-Negotiable Rules**:
- All function parameters MUST have type annotations
- All function return types MUST be annotated
- Complex types SHOULD use appropriate typing constructs
- API request/response schemas MUST be typed

**Rationale**: Improves code clarity, enables static analysis, and catches errors early.

### VI. Documentation

Every module MUST have documentation explaining its purpose.

**Non-Negotiable Rules**:
- Module-level docstrings are mandatory
- Public functions MUST have docstrings with parameter descriptions
- Classes MUST have docstrings explaining their responsibility
- API endpoints MUST be self-documenting (e.g., FastAPI's Swagger)

**Rationale**: Ensures code is self-documenting and maintainable by future developers (human or AI).

## Web Development Principles

### VII. Multi-User Isolation

Data MUST be strictly isolated by user ID. No user should ever access another user's tasks or data.

**Non-Negotiable Rules**:
- All database queries MUST filter by authenticated user ID
- API endpoints MUST validate user ownership before data access
- No cross-user data leakage is permitted under any circumstance
- RAG system MUST enforce strict isolation; the chatbot MUST never retrieve or "know" about tasks belonging to other users
- Vector database queries MUST include user ID filtering to prevent cross-user information leakage

**Rationale**: Fundamental security requirement for multi-tenant applications; protects user privacy and prevents information disclosure across user boundaries in both traditional data access and AI-powered features.

### VIII. Responsive Design

The UI MUST be "Mobile-First," ensuring usability on all screen sizes.

**Non-Negotiable Rules**:
- Tailwind CSS MUST be used for styling
- Mobile layouts MUST be the default, with desktop enhancements via breakpoints
- All interactive elements MUST be touch-friendly (minimum 44px tap targets)

**Rationale**: Majority of users access web applications on mobile devices; mobile-first ensures broad accessibility.

### IX. RESTful Integrity

All backend communication MUST follow standard HTTP methods and REST conventions.

**Non-Negotiable Rules**:
- GET for reading data (idempotent, no side effects)
- POST for creating resources
- PUT/PATCH for updating resources
- DELETE for removing resources
- Appropriate HTTP status codes MUST be returned

**Rationale**: RESTful APIs are predictable, cacheable, and widely understood; improves API usability.

## Technical Standards

### Database Safety

All interactions with Neon Postgres MUST use an ORM or safe query builders to prevent SQL injection.

**Non-Negotiable Rules**:
- Raw SQL queries are PROHIBITED unless explicitly justified and reviewed
- ORM (e.g., SQLAlchemy, Prisma) or parameterized queries MUST be used
- Database migrations MUST be version-controlled
- Connection pooling MUST be configured for production

**Rationale**: SQL injection remains a top security vulnerability; ORM abstractions provide safety by default.

### Authentication

User sessions MUST be managed exclusively through Better Auth.

**Non-Negotiable Rules**:
- No custom authentication implementations
- Session tokens MUST be securely stored (HTTP-only cookies)
- Password hashing MUST use industry-standard algorithms
- All authenticated routes MUST verify session validity

**Rationale**: Authentication is security-critical; using established libraries reduces vulnerability risk.

### API Documentation

Every endpoint MUST be typed and self-documenting.

**Non-Negotiable Rules**:
- FastAPI's automatic Swagger/OpenAPI generation MUST be enabled
- Request and response models MUST be defined with Pydantic
- API versioning strategy MUST be documented
- Error responses MUST follow consistent schema

**Rationale**: Self-documenting APIs reduce integration friction and improve developer experience.

## AI & RAG Governance

### X. Contextual Integrity

AI responses MUST be strictly grounded in the user's task data retrieved from the vector database to prevent hallucinations.

**Non-Negotiable Rules**:
- All AI-generated responses MUST cite specific retrieved documents or data
- RAG pipeline MUST retrieve relevant context before generating responses
- Responses without sufficient context MUST indicate uncertainty rather than fabricate information
- Vector embeddings MUST accurately represent user task data
- Retrieval relevance thresholds MUST be configured to prevent low-quality context injection

**Rationale**: AI hallucinations erode user trust and can provide misleading information; grounding responses in retrieved data ensures accuracy and reliability.

### XI. Multi-User RAG Isolation

The RAG system MUST enforce strict isolation; the chatbot MUST never retrieve or "know" about tasks belonging to other users.

**Non-Negotiable Rules**:
- All vector database queries MUST filter by authenticated user ID
- Vector embeddings MUST include user ID metadata for filtering
- Cross-user context bleeding MUST be prevented through technical controls (not just application logic)
- Chatbot responses MUST be validated to ensure no cross-user information appears
- Monitoring MUST be in place to detect any isolation violations

**Rationale**: RAG systems aggregate information from multiple sources; without strict isolation controls, user data can leak across boundaries, violating privacy and security requirements.

### XII. Privacy First

Personally Identifiable Information (PII) MUST be handled according to secure practices before being sent for embedding.

**Non-Negotiable Rules**:
- PII detection MUST be performed before sending data to external embedding services
- Sensitive fields (emails, phone numbers, addresses) MUST be redacted or tokenized before embedding
- User consent MUST be obtained for processing personal data through AI services
- Data retention policies MUST be documented and enforced for embeddings
- Third-party AI service providers MUST be vetted for privacy compliance

**Rationale**: Embedding services may retain or process data; protecting PII before external transmission is essential for privacy compliance and user trust.

## Localization & Personalization Standards

### XIII. Technical Translation

Urdu translations MUST preserve the technical context of software/hardware tasks.

**Non-Negotiable Rules**:
- Technical terminology MUST maintain accuracy across language translations
- Software and hardware task terms MUST be translated with domain awareness
- Translation system MUST support technical glossaries for consistent terminology
- Urdu UI elements MUST properly handle right-to-left (RTL) text rendering
- Date, time, and number formatting MUST respect locale conventions

**Rationale**: Incorrect technical translations can render tasks ambiguous or misleading; domain-aware translation ensures users can work effectively in their preferred language.

### XIV. Dynamic Personalization

The UI MUST adapt its suggestions and tone based on the user's "Software" or "Hardware" background collected at signup.

**Non-Negotiable Rules**:
- User background (Software/Hardware) MUST be captured during signup
- AI suggestions MUST be contextualized based on user background
- Task recommendations MUST align with user's technical domain
- Interface tone and terminology MUST adapt to user expertise level
- Personalization settings MUST be user-configurable and transparent

**Rationale**: Generic interfaces ignore user expertise and context; personalized experiences improve task relevance, user efficiency, and satisfaction.

## Traceability & Governance

### XV. Traceability

Every AI reasoning step MUST be captured in a Prompt History Record (PHR).

**Non-Negotiable Rules**:
- PHRs MUST be created for all significant user interactions
- PHRs MUST capture full user input (not truncated)
- PHRs MUST record AI responses and reasoning
- PHRs MUST be stored in appropriate subdirectories under `history/prompts/`
- PHR routing: Constitution → `history/prompts/constitution/`, Feature-specific → `history/prompts/<feature-name>/`, General → `history/prompts/general/`

**Rationale**: AI systems are non-deterministic; comprehensive traceability enables debugging, auditing, and continuous improvement of AI behavior.

## UI/UX Standards

**Web Consistency**: Web interface MUST provide clear, intuitive user experience.

**Non-Negotiable Rules**:
- Success and error states MUST be visually distinct
- Loading states MUST be indicated for async operations
- Form validation errors MUST be displayed inline
- Navigation MUST be consistent across all pages

**CLI Consistency** (Phase 1 compatibility): Console output MUST be clear, using consistent headers and success/error indicators.

**Rationale**: Users rely on visual feedback for operation confirmation; consistency reduces cognitive load.

## Governance

**Constitution Supersedes All Practices**: This constitution is the authoritative source for development standards. Conflicts with other documents MUST be resolved in favor of the constitution.

**Amendment Procedure**:
1. Proposed changes MUST be documented with rationale
2. Changes MUST be reviewed for impact on existing artifacts
3. Version number MUST be incremented per semantic versioning:
   - MAJOR: Backward-incompatible principle changes, new phases, or architecture shifts
   - MINOR: New principles or material expansions within current phase
   - PATCH: Clarifications and non-semantic refinements

**Compliance Review**:
- All PRs/reviews MUST verify constitution compliance
- Violations MUST be documented and justified if unavoidable
- Use `CLAUDE.md` for runtime development guidance

**Version**: 3.0.0 | **Ratified**: 2025-12-21 | **Last Amended**: 2025-12-23
